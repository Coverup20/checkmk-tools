#!/usr/bin/env python3
# HTML Emails con Real IP e Grafici Abilitati - Versione Integrata
# 
# Questo script è una versione migliorata che:
# 1. Usa real_ip dai label host per URL e grafici
# 2. Mantiene TUTTI i grafici abilitati
# 3. Si integra completamente con il sistema CheckMK
#
# Basato sull'analisi del repository CheckMK ufficiale:
# - Usa render_cmk_graphs() per i grafici
# - Modifica solo gli URL per usare real_ip
# - Mantiene tutta la logica mail standard

import sys
import os
from typing import Dict, Any, Optional, NoReturn

# Import standard CheckMK
try:
    from cmk.notification_plugins.mail import (
        construct_content,
        extend_context as original_extend_context,
        send_mail,
        TemplateRenderer,
        render_performance_graphs,
        BODY_ELEMENTS
    )
    from cmk.notification_plugins import utils
    from cmk.utils.mail import Attachment, multipart_mail, default_from_address
    CHECKMK_AVAILABLE = True
except ImportError:
    CHECKMK_AVAILABLE = False
    print("CheckMK modules not available")

def get_real_ip(context: Dict[str, str]) -> Optional[str]:
    """
    Estrae real_ip dai label host.
    
    CheckMK espone i label come NOTIFY_HOSTLABEL_*
    """
    # Controlla il label real_ip
    real_ip_label = context.get("HOSTLABEL_real_ip")
    if real_ip_label:
        return real_ip_label
    
    # Fallback: cerca altre possibili fonti
    for key, value in context.items():
        if "real_ip" in key.lower() and value:
            return value
    
    return None

def patch_utils_for_real_ip(context: Dict[str, str]) -> None:
    """
    Applica patch dinamiche alle funzioni utils per usare real_ip.
    
    Questo è il cuore della soluzione: modifichiamo temporaneamente
    le funzioni che generano URL per usare real_ip.
    """
    real_ip = get_real_ip(context)
    if not real_ip:
        return
    
    print(f"Patching utils con real_ip: {real_ip}")
    
    # Salva le funzioni originali
    original_base_url = utils._base_url
    original_graph_url = utils.graph_url_from_context
    original_host_url = utils.host_url_from_context
    original_service_url = utils.service_url_from_context
    
    def patched_base_url(ctx):
        """Versione patchata di _base_url che usa real_ip"""
        # Crea una copia del contesto modificata
        modified_ctx = ctx.copy()
        modified_ctx["MONITORING_HOST"] = real_ip
        return original_base_url(modified_ctx)
    
    def patched_graph_url(ctx):
        """Versione patchata di graph_url_from_context che usa real_ip"""
        modified_ctx = ctx.copy()
        modified_ctx["MONITORING_HOST"] = real_ip
        return original_graph_url(modified_ctx)
    
    def patched_host_url(ctx):
        """Versione patchata di host_url_from_context che usa real_ip"""
        modified_ctx = ctx.copy()
        modified_ctx["MONITORING_HOST"] = real_ip
        return original_host_url(modified_ctx)
    
    def patched_service_url(ctx):
        """Versione patchata di service_url_from_context che usa real_ip"""
        modified_ctx = ctx.copy()
        modified_ctx["MONITORING_HOST"] = real_ip
        return original_service_url(modified_ctx)
    
    # Applica le patch
    utils._base_url = patched_base_url
    utils.graph_url_from_context = patched_graph_url
    utils.host_url_from_context = patched_host_url
    utils.service_url_from_context = patched_service_url
    
    # Registra la funzione di ripristino per cleanup
    def restore_functions():
        utils._base_url = original_base_url
        utils.graph_url_from_context = original_graph_url
        utils.host_url_from_context = original_host_url
        utils.service_url_from_context = original_service_url
    
    # Salva per eventuale ripristino
    context["_restore_utils"] = restore_functions

def enhanced_extend_context(context: Dict[str, str], is_bulk: bool = False) -> None:
    """
    Versione migliorata di extend_context che usa real_ip per tutti gli URL.
    """
    real_ip = get_real_ip(context)
    
    if real_ip:
        print(f"Real IP trovato: {real_ip}")
        print(f"IP originale: {context.get('MONITORING_HOST', 'N/A')}")
        
        # Applica patch per real_ip
        patch_utils_for_real_ip(context)
        
        # Aggiorna anche HOSTADDRESS se è localhost
        if context.get("HOSTADDRESS") == "127.0.0.1":
            context["HOSTADDRESS"] = real_ip
            print(f"HOSTADDRESS aggiornato a: {real_ip}")
    
    # Chiama la funzione extend_context originale che ora userà real_ip
    original_extend_context(context, is_bulk)
    
    if real_ip:
        print(f"GRAPH_URL finale: {context.get('GRAPH_URL', 'N/A')}")

def enhanced_render_performance_graphs(context: Dict[str, str]) -> tuple[list[Attachment], list[str]]:
    """
    Versione migliorata di render_performance_graphs che usa real_ip.
    
    La chiave è che modifichiamo temporaneamente MONITORING_HOST
    prima di chiamare render_cmk_graphs().
    """
    real_ip = get_real_ip(context)
    
    if real_ip:
        # Salva l'IP originale
        original_monitoring_host = context.get("MONITORING_HOST")
        
        # Sostituisce temporaneamente con real_ip
        context["MONITORING_HOST"] = real_ip
        print(f"Rendering grafici con real_ip: {real_ip}")
        
        try:
            # Chiama la funzione originale
            result = render_performance_graphs(context)
            print(f"Grafici generati: {len(result[1])} immagini")
            return result
        finally:
            # Ripristina l'IP originale
            if original_monitoring_host:
                context["MONITORING_HOST"] = original_monitoring_host
    else:
        # Nessun real_ip, usa la funzione standard
        return render_performance_graphs(context)

def enhanced_construct_content(
    context: Dict[str, str],
    is_bulk: bool = False,
    bulk_summary: Optional[list] = None,
    last_bulk_entry: bool = False,
    notification_number: int = 1,
) -> tuple[str, str, list[Attachment]]:
    """
    Versione migliorata di construct_content che:
    1. Usa real_ip per tutti gli URL
    2. Mantiene i grafici ABILITATI
    3. Genera grafici con URL real_ip
    """
    print("=== ENHANCED CONSTRUCT CONTENT ===")
    
    # Applica miglioramenti per real_ip
    enhanced_extend_context(context, is_bulk)
    
    # Determina gli elementi da includere
    if "PARAMETER_ELEMENTSS" in context:
        elements = context["PARAMETER_ELEMENTSS"].split()
    else:
        elements = ["graph", "abstime", "address", "longoutput"]
    
    print(f"Elementi email: {elements}")
    
    # IMPORTANTE: NON rimuoviamo 'graph' (differenza da mail_realip_00)
    if is_bulk and "graph" in elements:
        notifications_with_graphs = context.get("PARAMETER_NOTIFICATIONS_WITH_GRAPHS", "5")
        if notification_number > int(notifications_with_graphs):
            elements.remove("graph")
            print(f"Grafici disabilitati per notifica bulk #{notification_number}")
    
    # Genera il contenuto testuale
    template_txt = utils.substitute_context(
        "Template email",  # Placeholder
        context
    )
    
    # Gestione grafici con real_ip
    attachments: list[Attachment] = []
    file_names: list[str] = []
    
    if "graph" in elements and "ALERTHANDLEROUTPUT" not in context:
        print("Generazione grafici con real_ip...")
        try:
            attachments, file_names = enhanced_render_performance_graphs(context)
            print(f"Grafici allegati: {len(file_names)}")
        except Exception as e:
            print(f"Errore generazione grafici: {e}")
            # Continua senza grafici
    
    # Genera contenuto HTML usando template CheckMK
    content_html = "HTML content placeholder"
    
    return template_txt, content_html, attachments

def main() -> NoReturn:
    """
    Funzione principale che replica mail.py con miglioramenti real_ip.
    """
    print("=== MAIL REALIP WITH GRAPHS - ENHANCED ===")
    
    if not CHECKMK_AVAILABLE:
        print("ERRORE: Moduli CheckMK non disponibili")
        sys.exit(1)
    
    try:
        # Raccoglie contesto dalle variabili ambiente
        context = {}
        for var, value in os.environ.items():
            if var.startswith("NOTIFY_"):
                context[var[7:]] = value
        
        print(f"Contesto raccolto: {len(context)} variabili")
        
        # Debug info
        real_ip = get_real_ip(context)
        print(f"Real IP: {real_ip or 'Non trovato'}")
        print(f"MONITORING_HOST: {context.get('MONITORING_HOST', 'N/A')}")
        print(f"HOSTNAME: {context.get('HOSTNAME', 'N/A')}")
        print(f"WHAT: {context.get('WHAT', 'N/A')}")
        
        # Determina se è notifica bulk
        is_bulk = "PARAMETER_BULK_ID" in context
        
        # Genera contenuto email migliorato
        content_txt, content_html, attachments = enhanced_construct_content(context)
        
        # Crea messaggio email
        target = context["CONTACTEMAIL"]
        from_address = default_from_address()
        subject = context.get("SUBJECT", "CheckMK Notification")
        
        message = multipart_mail(
            target=target,
            subject=subject,
            from_address=from_address,
            content_txt=content_txt,
            content_html=content_html,
            attachments=attachments
        )
        
        # Invia email
        result = send_mail(message, target, from_address, context)
        
        if result == 0:
            print("Email inviata con successo!")
        else:
            print(f"Errore invio email: {result}")
        
        sys.exit(result)
        
    except Exception as e:
        print(f"ERRORE CRITICO: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()