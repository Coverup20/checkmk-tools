#!/usr/bin/env python3
# HTML Emails con Real IP e Grafici Abilitati
# 
# Questo script migliora la notifica email standard di CheckMK combinando:
# - Real IP (dal label host) per collegamenti e grafici
# - Grafici abilitati (a differenza dello script mail_realip_00)
# - Tutto il resto identico al comportamento standard
#
# Differenze principali:
# 1. Usa real_ip dal label host quando disponibile
# 2. NON disabilita i grafici (rimuove _no_graphs)
# 3. Modifica l'URL dei grafici per usare real_ip

import os
import sys
import re
from typing import Dict, Any, Optional

# Importiamo tutte le funzioni necessarie dal modulo mail standard
try:
    # Tentiamo di importare le funzioni dal modulo mail di CheckMK
    from cmk.notification_plugins.mail import (
        main as mail_main,
        construct_content,
        extend_context,
        send_mail,
        collect_context,
        TemplateRenderer
    )
    from cmk.notification_plugins import utils
    from cmk.utils.mail import Attachment
except ImportError:
    # Se non riusciamo a importare, definiamo funzioni base
    print("Avviso: Moduli CheckMK non disponibili, modalità standalone")
    
    def collect_context():
        """Raccoglie il contesto dalle variabili di ambiente NOTIFY_*"""
        context = {}
        for var, value in os.environ.items():
            if var.startswith("NOTIFY_"):
                context[var[7:]] = value
        return context

def get_real_ip_from_labels(context: Dict[str, str]) -> Optional[str]:
    """
    Estrae il real_ip dai label host se disponibile.
    
    CheckMK espone i label host come variabili NOTIFY_HOSTLABEL_*
    Cerchiamo specificamente NOTIFY_HOSTLABEL_real_ip
    """
    real_ip_key = "HOSTLABEL_real_ip"
    if real_ip_key in context:
        real_ip = context[real_ip_key]
        print(f"Real IP trovato dai label: {real_ip}")
        return real_ip
    
    # Fallback: controlla anche nei parametri personalizzati
    for key, value in context.items():
        if "real_ip" in key.lower() and value:
            print(f"Real IP trovato da {key}: {value}")
            return value
    
    print("Real IP non trovato nei label, uso IP standard")
    return None

def modify_context_for_real_ip(context: Dict[str, str]) -> Dict[str, str]:
    """
    Modifica il contesto per usare real_ip quando disponibile.
    
    Questa funzione:
    1. Trova il real_ip dai label
    2. Sostituisce l'IP di monitoraggio con real_ip per URL e grafici
    3. Mantiene tutto il resto invariato
    """
    modified_context = context.copy()
    
    # Trova il real_ip
    real_ip = get_real_ip_from_labels(context)
    if not real_ip:
        return modified_context
    
    # Salva l'IP originale per debug
    original_monitoring_host = context.get("MONITORING_HOST", "")
    print(f"IP monitoraggio originale: {original_monitoring_host}")
    print(f"Sostituisco con real IP: {real_ip}")
    
    # Sostituisce MONITORING_HOST con real_ip per tutti gli URL
    modified_context["MONITORING_HOST"] = real_ip
    
    # Aggiorna anche HOSTADDRESS se necessario
    if "HOSTADDRESS" in modified_context and modified_context["HOSTADDRESS"] == "127.0.0.1":
        modified_context["HOSTADDRESS"] = real_ip
        print(f"HOSTADDRESS aggiornato a: {real_ip}")
    
    return modified_context

def patch_graph_functions():
    """
    Applica patch alle funzioni di grafico per usare real_ip.
    
    Questo è il trucco principale: modifichiamo le funzioni che generano
    gli URL dei grafici per usare il real_ip invece dell'IP di monitoraggio.
    """
    try:
        # Patch della funzione graph_url_from_context
        original_graph_url = utils.graph_url_from_context
        
        def patched_graph_url(context):
            # Usa il contesto modificato con real_ip
            modified_context = modify_context_for_real_ip(context)
            return original_graph_url(modified_context)
        
        utils.graph_url_from_context = patched_graph_url
        print("Patch applicata a graph_url_from_context")
        
        # Patch della funzione _base_url se esiste
        if hasattr(utils, '_base_url'):
            original_base_url = utils._base_url
            
            def patched_base_url(context):
                modified_context = modify_context_for_real_ip(context)
                return original_base_url(modified_context)
            
            utils._base_url = patched_base_url
            print("Patch applicata a _base_url")
            
    except Exception as e:
        print(f"Errore nell'applicazione delle patch: {e}")

def enhanced_extend_context(context: Dict[str, str], is_bulk: bool = False) -> None:
    """
    Versione migliorata di extend_context che usa real_ip.
    
    Prima applica le modifiche per real_ip, poi chiama la funzione originale.
    """
    # Modifica il contesto per usare real_ip
    modified_context = modify_context_for_real_ip(context)
    
    # Copia le modifiche nel contesto originale
    context.update(modified_context)
    
    # Chiama la funzione extend_context originale
    try:
        extend_context(context, is_bulk)
    except NameError:
        # Se extend_context non è disponibile, gestiamo manualmente
        print("extend_context non disponibile, gestione manuale URL")
        
        # Crea manualmente gli URL con real_ip
        if "graph" in context.get("PARAMETER_ELEMENTSS", "graph").split():
            real_ip = get_real_ip_from_labels(context)
            if real_ip:
                # Costruisce l'URL del grafico con real_ip
                if context["WHAT"] == "HOST":
                    graph_url = (f"https://{real_ip}/{context['OMD_SITE']}/check_mk/view.py?"
                               f"siteopt={context['OMD_SITE']}&"
                               f"view_name=host_graphs&"
                               f"host={context['HOSTNAME']}")
                else:
                    graph_url = (f"https://{real_ip}/{context['OMD_SITE']}/check_mk/view.py?"
                               f"siteopt={context['OMD_SITE']}&"
                               f"view_name=service_graphs&"
                               f"host={context['HOSTNAME']}&"
                               f"service={context['SERVICEDESC']}")
                
                context["GRAPH_URL"] = graph_url
                print(f"GRAPH_URL impostato a: {graph_url}")

def enhanced_main():
    """
    Funzione principale migliorata che combina real_ip e grafici.
    
    Flusso:
    1. Raccoglie il contesto
    2. Applica le patch per real_ip  
    3. Modifica il contesto per usare real_ip
    4. NON disabilita i grafici (differenza principale da mail_realip_00)
    5. Chiama la funzione mail principale
    """
    print("=== MAIL REALIP WITH GRAPHS ===")
    print("Avvio notifica email con real IP e grafici abilitati")
    
    try:
        # Raccoglie il contesto
        context = collect_context()
        print(f"Contesto raccolto: {len(context)} variabili")
        
        # Debug: mostra variabili rilevanti
        for key in ["HOSTNAME", "MONITORING_HOST", "HOSTADDRESS", "WHAT"]:
            if key in context:
                print(f"{key}: {context[key]}")
        
        # Mostra i label disponibili
        for key, value in context.items():
            if key.startswith("HOSTLABEL_"):
                print(f"Label trovato: {key} = {value}")
        
        # Applica le patch per real_ip
        patch_graph_functions()
        
        # Modifica il contesto per usare real_ip
        enhanced_extend_context(context)
        
        # DEBUG: Non disabilitiamo i grafici (questa è la differenza chiave!)
        print("IMPORTANTE: Grafici ABILITATI (diversamente da mail_realip_00)")
        
        # Chiama la funzione mail principale se disponibile
        try:
            mail_main()
        except NameError:
            print("mail_main non disponibile, gestione manuale")
            # Gestione manuale semplificata
            print("Invio email manuale non implementato in modalità standalone")
            sys.exit(0)
            
    except Exception as e:
        print(f"ERRORE: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    enhanced_main()