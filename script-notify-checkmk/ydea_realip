#!/usr/bin/env bash
# ydea_realip - CheckMK notification script per Ydea ticketing
# Gestisce creazione automatica ticket e aggiornamenti con note private
set -euo pipefail

# ===== CONFIG =====
YDEA_TOOLKIT_DIR="/opt/ydea-toolkit"
YDEA_TOOLKIT="${YDEA_TOOLKIT_DIR}/ydea-toolkit.sh"
YDEA_ENV="${YDEA_TOOLKIT_DIR}/.env"
TICKET_CACHE="/tmp/ydea_checkmk_tickets.json"
FLAPPING_CACHE="/tmp/ydea_checkmk_flapping.json"
FLAPPING_THRESHOLD=5  # Numero cambi stato in finestra temporale
FLAPPING_WINDOW=600   # Finestra temporale in secondi (10 minuti)

# ===== UTILITY =====
log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >&2; }
debug() { [[ "${DEBUG_YDEA:-0}" == "1" ]] && log "DEBUG: $*" || true; }

# Inizializza cache se non esiste
init_cache() {
  if [[ ! -f "$TICKET_CACHE" ]]; then
    echo '{}' > "$TICKET_CACHE"
    chmod 666 "$TICKET_CACHE" 2>/dev/null || true
  fi
  if [[ ! -f "$FLAPPING_CACHE" ]]; then
    echo '{}' > "$FLAPPING_CACHE"
    chmod 666 "$FLAPPING_CACHE" 2>/dev/null || true
  fi
}

# ===== FUNZIONI CACHE =====
# Genera chiave univoca per ticket: IP/HOSTNAME:SERVIZIO
get_ticket_key() {
  local host="${1}"
  local service="${2:-HOST}"
  echo "${host}:${service}"
}

# Verifica se esiste ticket aperto per questo alert
ticket_exists() {
  local key="$1"
  init_cache
  jq -e --arg key "$key" '.[$key] != null' "$TICKET_CACHE" >/dev/null 2>&1
}

# Ottieni ID ticket dalla cache
get_ticket_id() {
  local key="$1"
  init_cache
  jq -r --arg key "$key" '.[$key].ticket_id // empty' "$TICKET_CACHE"
}

# Salva ticket in cache
save_ticket_cache() {
  local key="$1"
  local ticket_id="$2"
  local state="$3"
  init_cache
  jq --arg key "$key" \
     --arg id "$ticket_id" \
     --arg state "$state" \
     --arg ts "$(date -u +%s)" \
    '.[$key] = {ticket_id: $id, state: $state, created_at: $ts, last_update: $ts}' \
    "$TICKET_CACHE" > "${TICKET_CACHE}.tmp" && cat "${TICKET_CACHE}.tmp" > "$TICKET_CACHE" && rm -f "${TICKET_CACHE}.tmp"
  debug "Ticket salvato in cache: $key -> $ticket_id"
}

# Aggiorna ultimo stato in cache
update_ticket_state() {
  local key="$1"
  local state="$2"
  init_cache
  jq --arg key "$key" \
     --arg state "$state" \
     --arg ts "$(date -u +%s)" \
    '.[$key].state = $state | .[$key].last_update = $ts' \
    "$TICKET_CACHE" > "${TICKET_CACHE}.tmp" && cat "${TICKET_CACHE}.tmp" > "$TICKET_CACHE" && rm -f "${TICKET_CACHE}.tmp"
}

# ===== FLAPPING DETECTION =====
# Registra cambio stato per detection flapping
record_state_change() {
  local key="$1"
  local state="$2"
  local now="$(date -u +%s)"
  init_cache
  
  # Aggiungi nuovo cambio stato
  jq --arg key "$key" \
     --arg state "$state" \
     --arg ts "$now" \
    '.[$key] = ((.[$key] // []) + [{state: $state, timestamp: ($ts|tonumber)}])' \
    "$FLAPPING_CACHE" > "${FLAPPING_CACHE}.tmp" && cat "${FLAPPING_CACHE}.tmp" > "$FLAPPING_CACHE" && rm -f "${FLAPPING_CACHE}.tmp"
  
  # Pulisci eventi vecchi (fuori dalla finestra temporale)
  local cutoff=$((now - FLAPPING_WINDOW))
  jq --arg key "$key" \
     --arg cutoff "$cutoff" \
    '.[$key] = [.[$key][] | select(.timestamp > ($cutoff|tonumber))]' \
    "$FLAPPING_CACHE" > "${FLAPPING_CACHE}.tmp" && cat "${FLAPPING_CACHE}.tmp" > "$FLAPPING_CACHE" && rm -f "${FLAPPING_CACHE}.tmp"
}

# Verifica se il servizio √® in flapping
is_flapping() {
  local key="$1"
  init_cache
  local count=$(jq --arg key "$key" '.[$key] // [] | length' "$FLAPPING_CACHE")
  [[ "$count" -ge "$FLAPPING_THRESHOLD" ]]
}

# Ottieni conteggio cambi stato
get_state_changes_count() {
  local key="$1"
  init_cache
  jq --arg key "$key" '.[$key] // [] | length' "$FLAPPING_CACHE"
}

# ===== EMOJI PER STATI =====
get_emoji() {
  case "${1^^}" in
    OK|UP) echo "üü¢" ;;
    WARN|WARNING) echo "üü°" ;;
    CRIT|CRITICAL|DOWN) echo "üî¥" ;;
    UNKNOWN) echo "‚ö™" ;;
    *) echo "‚ö†Ô∏è" ;;
  esac
}

# ===== FORMATTAZIONE OUTPUT =====
# Formatta output plugin in modo pi√π leggibile (sintetico)
format_output() {
  local output="$1"
  # Rimuovi caratteri speciali eccessivi e limita lunghezza
  echo "$output" | tr -d '\r' | head -c 500
}

# ===== GESTIONE TICKET YDEA =====
# Carica ambiente Ydea
load_ydea_env() {
  if [[ ! -f "$YDEA_ENV" ]]; then
    log "ERRORE: File .env non trovato in $YDEA_ENV"
    exit 1
  fi
  source "$YDEA_ENV"
  
  if [[ ! -x "$YDEA_TOOLKIT" ]]; then
    log "ERRORE: Script ydea-toolkit.sh non trovato o non eseguibile in $YDEA_TOOLKIT"
    exit 1
  fi
}

# Crea nuovo ticket su Ydea
create_ydea_ticket() {
  local title="$1"
  local description="$2"
  local priority="$3"
  
  debug "Creazione ticket: $title"
  local result
  result=$("$YDEA_TOOLKIT" create "$title" "$description" "$priority" 2>&1) || {
    log "ERRORE creazione ticket: $result"
    return 1
  }
  
  # Estrai solo l'ultima riga JSON dalla risposta (ignora messaggi info)
  local json_line
  json_line=$(echo "$result" | grep -E '^\{.*\}$' | tail -n1)
  
  local ticket_id
  ticket_id=$(echo "$json_line" | jq -r '.id // .data.id // empty' 2>/dev/null)
  
  if [[ -z "$ticket_id" || "$ticket_id" == "null" ]]; then
    log "ERRORE: Nessun ticket_id nella risposta: $result"
    return 1
  fi
  
  # Aggiungi descrizione come commento pubblico (l'API non supporta testo in creazione)
  if [[ -n "$description" ]]; then
    debug "Aggiunta descrizione come commento pubblico al ticket #$ticket_id"
    "$YDEA_TOOLKIT" comment "$ticket_id" "$description" true 2>&1 || {
      log "WARN: Impossibile aggiungere descrizione al ticket #$ticket_id"
    }
  fi
  
  echo "$ticket_id"
}

# Aggiungi nota privata a ticket esistente
add_private_note() {
  local ticket_id="$1"
  local note="$2"
  
  debug "Aggiunta nota privata a ticket #$ticket_id"
  local result
  result=$("$YDEA_TOOLKIT" comment "$ticket_id" "$note" 2>&1) || {
    # Verifica se √® un errore 404 (ticket non trovato/chiuso)
    if echo "$result" | grep -q "404\|not found\|Not Found"; then
      log "WARN: Ticket #$ticket_id non trovato (404) - potrebbe essere stato chiuso"
      return 2  # Return code speciale per 404
    else
      log "ERRORE aggiunta nota a ticket #$ticket_id: $result"
      return 1
    fi
  }
  
  # Successo
  return 0
}

# Rimuovi ticket dalla cache
remove_ticket_from_cache() {
  local key="$1"
  init_cache
  
  debug "Rimozione ticket dalla cache: $key"
  jq --arg key "$key" 'del(.[$key])' "$TICKET_CACHE" > "${TICKET_CACHE}.tmp" && \
    cat "${TICKET_CACHE}.tmp" > "$TICKET_CACHE" && \
    rm -f "${TICKET_CACHE}.tmp"
}

# ===== MAIN LOGIC =====
main() {
  # Carica configurazione Ydea
  load_ydea_env
  
  # Ottieni Real IP (da label o fallback a NOTIFY_HOSTADDRESS)
  REAL_IP="${NOTIFY_HOSTLABEL_real_ip:-${NOTIFY_HOSTADDRESS:-unknown}}"
  HOSTNAME="${NOTIFY_HOSTNAME:-unknown}"
  
  # Determina se √® alert HOST o SERVICE
  if [[ "${NOTIFY_WHAT:-SERVICE}" == "SERVICE" ]]; then
    # === ALERT SERVICE ===
    SERVICE="${NOTIFY_SERVICEDESC:-UNKNOWN}"
    STATE="${NOTIFY_SERVICESTATE:-UNKNOWN}"
    LAST_STATE="${NOTIFY_LASTSERVICESTATE:-UNKNOWN}"
    OUTPUT="${NOTIFY_SERVICEOUTPUT:-N/A}"
    STATE_TYPE="${NOTIFY_SERVICESTATETYPE:-HARD}"
    
    TICKET_KEY=$(get_ticket_key "$REAL_IP" "$SERVICE")
    
    # Formatta output sintetico
    OUTPUT_SHORT=$(format_output "$OUTPUT")
    
    log "SERVICE Alert: $HOSTNAME ($REAL_IP) - $SERVICE | $LAST_STATE -> $STATE"
    
    # Registra cambio stato per flapping detection
    record_state_change "$TICKET_KEY" "$STATE"
    
    # Verifica flapping
    FLAPPING_STATUS=""
    if is_flapping "$TICKET_KEY"; then
      FLAPPING_COUNT=$(get_state_changes_count "$TICKET_KEY")
      FLAPPING_STATUS="‚ö†Ô∏è FLAPPING (${FLAPPING_COUNT} cambi in $((FLAPPING_WINDOW/60))min)"
      log "FLAPPING rilevato per $TICKET_KEY"
    fi
    
    # === LOGICA GESTIONE TICKET ===
    if ticket_exists "$TICKET_KEY"; then
      # Ticket gi√† esiste -> aggiungi nota privata
      TICKET_ID=$(get_ticket_id "$TICKET_KEY")
      log "Ticket esistente trovato: #$TICKET_ID"
      
      # Prepara nota privata sintetica
      NOTE="[$(date '+%d/%m/%y %H:%M')] ${LAST_STATE} -> ${STATE}"
      
      # Aggiungi dettagli stato
      if [[ "$STATE" == "OK" || "$STATE" == "UP" ]]; then
        NOTE="${NOTE} | Allarme rientrato"
      elif [[ -n "$FLAPPING_STATUS" ]]; then
        NOTE="${NOTE} | ${FLAPPING_STATUS}"
      fi
      
      # Aggiungi output se significativo
      NOTE="${NOTE} | Output: ${OUTPUT_SHORT}"
      
      # Aggiungi nota
      add_private_note "$TICKET_ID" "$NOTE"
      local note_result=$?
      
      if [[ $note_result -eq 0 ]]; then
        log "Nota privata aggiunta al ticket #$TICKET_ID"
        update_ticket_state "$TICKET_KEY" "$STATE"
      elif [[ $note_result -eq 2 ]]; then
        # Errore 404 - ticket non esiste pi√π
        log "Ticket #$TICKET_ID non pi√π valido, rimozione dalla cache"
        remove_ticket_from_cache "$TICKET_KEY"
        
        # Se lo stato √® ancora critico, crea un nuovo ticket
        if [[ "$STATE" == "CRIT" || "$STATE" == "CRITICAL" || "$STATE" == "DOWN" ]]; then
          log "Stato ancora CRITICAL, creazione nuovo ticket"
          
          # Determina priorit√†
          PRIORITY="urgent"
          if [[ -n "$FLAPPING_STATUS" ]]; then
            PRIORITY="critical"
          fi
          
          # Prepara titolo e descrizione (stessa logica di creazione nuovo ticket)
          TITLE="[${STATE}] ${HOSTNAME} - ${SERVICE}"
          
          DESCRIPTION="ALERT DI MONITORAGGIO - CheckMK

===========================================
DETTAGLI SERVIZIO
===========================================

Host:              ${HOSTNAME}
Indirizzo IP:      ${REAL_IP}
Servizio:          ${SERVICE}
Stato corrente:    ${STATE}
Stato precedente:  ${LAST_STATE}
Tipo notifica:     ${STATE_TYPE}
Timestamp:         $(date '+%Y-%m-%d %H:%M:%S')
${FLAPPING_STATUS:+
-------------------------------------------
ATTENZIONE: ${FLAPPING_STATUS}
-------------------------------------------
}
===========================================
OUTPUT DIAGNOSTICO
===========================================

${OUTPUT_SHORT}

===========================================
DETTAGLI TECNICI
===========================================

Tipo notifica:     ${NOTIFY_NOTIFICATIONTYPE:-N/A}
Tentativo check:   ${NOTIFY_SERVICEATTEMPT:-N/A}/${NOTIFY_SERVICEMAXATTEMPTS:-N/A}
Durata stato:      ${NOTIFY_SERVICESTATEID:-N/A}
Ultimo check:      ${NOTIFY_LASTSERVICECHECK:-N/A}
Prossimo check:    ${NOTIFY_NEXTSERVICECHECK:-N/A}

-------------------------------------------
‚ö†Ô∏è NOTA: Ticket precedente #${TICKET_ID} non pi√π disponibile
Nuovo ticket creato automaticamente
-------------------------------------------
Generato automaticamente da CheckMK
Sito: ${NOTIFY_OMD_SITE:-monitoring}
-------------------------------------------"
          
          # Crea nuovo ticket
          NEW_TICKET_ID=$(create_ydea_ticket "$TITLE" "$DESCRIPTION" "$PRIORITY")
          
          if [[ -n "$NEW_TICKET_ID" ]]; then
            log "‚úÖ Nuovo ticket creato: #$NEW_TICKET_ID (sostituisce #$TICKET_ID)"
            save_ticket_cache "$TICKET_KEY" "$NEW_TICKET_ID" "$STATE"
          else
            log "‚ùå Errore creazione nuovo ticket per $TICKET_KEY"
          fi
        else
          log "Stato $STATE non critico, nessun nuovo ticket creato"
        fi
      else
        # Altro errore generico
        log "Errore generico aggiunta nota al ticket #$TICKET_ID"
      fi
      
    elif [[ "$STATE" == "CRIT" || "$STATE" == "CRITICAL" || "$STATE" == "DOWN" ]]; then
      # Nuovo problema CRITICAL -> crea ticket
      log "Nuovo problema CRITICAL: creazione ticket"
      
      # Determina priorit√† (sempre urgent per CRITICAL, critical per flapping)
      PRIORITY="urgent"
      if [[ -n "$FLAPPING_STATUS" ]]; then
        PRIORITY="critical"
      fi
      
      # Prepara titolo e descrizione
      TITLE="[${STATE}] ${HOSTNAME} - ${SERVICE}"
      
      DESCRIPTION="ALERT DI MONITORAGGIO - CheckMK

===========================================
DETTAGLI SERVIZIO
===========================================

Host:              ${HOSTNAME}
Indirizzo IP:      ${REAL_IP}
Servizio:          ${SERVICE}
Stato corrente:    ${STATE}
Stato precedente:  ${LAST_STATE}
Tipo notifica:     ${STATE_TYPE}
Timestamp:         $(date '+%Y-%m-%d %H:%M:%S')
${FLAPPING_STATUS:+
-------------------------------------------
ATTENZIONE: ${FLAPPING_STATUS}
-------------------------------------------
}
===========================================
OUTPUT DIAGNOSTICO
===========================================

${OUTPUT_SHORT}

===========================================
DETTAGLI TECNICI
===========================================

Tipo notifica:     ${NOTIFY_NOTIFICATIONTYPE:-N/A}
Tentativo check:   ${NOTIFY_SERVICEATTEMPT:-N/A}/${NOTIFY_SERVICEMAXATTEMPTS:-N/A}
Durata stato:      ${NOTIFY_SERVICESTATEID:-N/A}
Ultimo check:      ${NOTIFY_LASTSERVICECHECK:-N/A}
Prossimo check:    ${NOTIFY_NEXTSERVICECHECK:-N/A}

-------------------------------------------
Generato automaticamente da CheckMK
Sito: ${NOTIFY_OMD_SITE:-monitoring}
-------------------------------------------"
      
      # Crea ticket
      TICKET_ID=$(create_ydea_ticket "$TITLE" "$DESCRIPTION" "$PRIORITY")
      
      if [[ -n "$TICKET_ID" ]]; then
        log "‚úÖ Ticket creato: #$TICKET_ID per $TICKET_KEY"
        save_ticket_cache "$TICKET_KEY" "$TICKET_ID" "$STATE"
      else
        log "‚ùå Errore creazione ticket per $TICKET_KEY"
      fi
    else
      # Stato WARNING o UNKNOWN, non CRITICAL -> solo log
      log "Stato $STATE non critico, nessun ticket creato"
    fi
    
  else
    # === ALERT HOST ===
    STATE="${NOTIFY_HOSTSTATE:-UNKNOWN}"
    LAST_STATE="${NOTIFY_LASTHOSTSTATE:-UNKNOWN}"
    OUTPUT="${NOTIFY_HOSTOUTPUT:-N/A}"
    STATE_TYPE="${NOTIFY_HOSTSTATETYPE:-HARD}"
    
    TICKET_KEY=$(get_ticket_key "$REAL_IP" "HOST")
    
    OUTPUT_SHORT=$(format_output "$OUTPUT")
    
    log "HOST Alert: $HOSTNAME ($REAL_IP) | $LAST_STATE -> $STATE"
    
    # Registra cambio stato
    record_state_change "$TICKET_KEY" "$STATE"
    
    # Verifica flapping
    FLAPPING_STATUS=""
    if is_flapping "$TICKET_KEY"; then
      FLAPPING_COUNT=$(get_state_changes_count "$TICKET_KEY")
      FLAPPING_STATUS="‚ö†Ô∏è FLAPPING (${FLAPPING_COUNT} cambi in $((FLAPPING_WINDOW/60))min)"
    fi
    
    # Gestione ticket host
    if ticket_exists "$TICKET_KEY"; then
      TICKET_ID=$(get_ticket_id "$TICKET_KEY")
      
      NOTE="[$(date '+%d/%m/%y %H:%M')] ${LAST_STATE} -> ${STATE}"
      if [[ "$STATE" == "OK" || "$STATE" == "UP" ]]; then
        NOTE="${NOTE} | Allarme rientrato"
      elif [[ -n "$FLAPPING_STATUS" ]]; then
        NOTE="${NOTE} | ${FLAPPING_STATUS}"
      fi
      NOTE="${NOTE} | Output: ${OUTPUT_SHORT}"
      
      add_private_note "$TICKET_ID" "$NOTE"
      local note_result=$?
      
      if [[ $note_result -eq 0 ]]; then
        log "Nota privata aggiunta al ticket #$TICKET_ID"
        update_ticket_state "$TICKET_KEY" "$STATE"
      elif [[ $note_result -eq 2 ]]; then
        # Errore 404 - ticket non esiste pi√π
        log "Ticket #$TICKET_ID non pi√π valido, rimozione dalla cache"
        remove_ticket_from_cache "$TICKET_KEY"
        
        # Se lo stato √® ancora critico, crea un nuovo ticket
        if [[ "$STATE" == "DOWN" || "$STATE" == "CRITICAL" ]]; then
          log "Stato ancora CRITICAL/DOWN, creazione nuovo ticket"
          
          PRIORITY="critical"
          TITLE="[${STATE}] ${HOSTNAME}"
          
          DESCRIPTION="ALERT DI MONITORAGGIO - CheckMK

===========================================
HOST DOWN
===========================================

Hostname:          ${HOSTNAME}
Indirizzo IP:      ${REAL_IP}
Stato corrente:    ${STATE}
Stato precedente:  ${LAST_STATE}
Tipo notifica:     ${STATE_TYPE}
Timestamp:         $(date '+%Y-%m-%d %H:%M:%S')
${FLAPPING_STATUS:+
-------------------------------------------
ATTENZIONE: ${FLAPPING_STATUS}
-------------------------------------------
}
===========================================
OUTPUT DIAGNOSTICO
===========================================

${OUTPUT_SHORT}

===========================================
AZIONI CONSIGLIATE
===========================================

1. Verificare connettivita di rete
2. Controllare status hardware/VM
3. Verificare log di sistema
4. Valutare restart servizi se necessario

===========================================
DETTAGLI TECNICI
===========================================

Tipo notifica:     ${NOTIFY_NOTIFICATIONTYPE:-N/A}
Tentativo check:   ${NOTIFY_HOSTATTEMPT:-N/A}/${NOTIFY_HOSTMAXATTEMPTS:-N/A}
Durata stato:      ${NOTIFY_HOSTSTATEID:-N/A}
Ultimo check:      ${NOTIFY_LASTHOSTCHECK:-N/A}

-------------------------------------------
‚ö†Ô∏è NOTA: Ticket precedente #${TICKET_ID} non pi√π disponibile
Nuovo ticket creato automaticamente
-------------------------------------------
Generato automaticamente da CheckMK
Sito: ${NOTIFY_OMD_SITE:-monitoring}
-------------------------------------------"
          
          NEW_TICKET_ID=$(create_ydea_ticket "$TITLE" "$DESCRIPTION" "$PRIORITY")
          
          if [[ -n "$NEW_TICKET_ID" ]]; then
            log "‚úÖ Nuovo ticket creato: #$NEW_TICKET_ID (sostituisce #$TICKET_ID)"
            save_ticket_cache "$TICKET_KEY" "$NEW_TICKET_ID" "$STATE"
          fi
        else
          log "Stato $STATE non critico, nessun nuovo ticket creato"
        fi
      else
        # Altro errore generico
        log "Errore generico aggiunta nota al ticket #$TICKET_ID"
      fi
      
    elif [[ "$STATE" == "DOWN" || "$STATE" == "CRITICAL" ]]; then
      log "Nuovo problema HOST DOWN: creazione ticket"
      
      PRIORITY="critical"
      TITLE="[${STATE}] ${HOSTNAME}"
      
      DESCRIPTION="ALERT DI MONITORAGGIO - CheckMK

===========================================
HOST DOWN
===========================================

Hostname:          ${HOSTNAME}
Indirizzo IP:      ${REAL_IP}
Stato corrente:    ${STATE}
Stato precedente:  ${LAST_STATE}
Tipo notifica:     ${STATE_TYPE}
Timestamp:         $(date '+%Y-%m-%d %H:%M:%S')
${FLAPPING_STATUS:+
-------------------------------------------
ATTENZIONE: ${FLAPPING_STATUS}
-------------------------------------------
}
===========================================
OUTPUT DIAGNOSTICO
===========================================

${OUTPUT_SHORT}

===========================================
AZIONI CONSIGLIATE
===========================================

1. Verificare connettivita di rete
2. Controllare status hardware/VM
3. Verificare log di sistema
4. Valutare restart servizi se necessario

===========================================
DETTAGLI TECNICI
===========================================

Tipo notifica:     ${NOTIFY_NOTIFICATIONTYPE:-N/A}
Tentativo check:   ${NOTIFY_HOSTATTEMPT:-N/A}/${NOTIFY_HOSTMAXATTEMPTS:-N/A}
Durata stato:      ${NOTIFY_HOSTSTATEID:-N/A}
Ultimo check:      ${NOTIFY_LASTHOSTCHECK:-N/A}

-------------------------------------------
Generato automaticamente da CheckMK
Sito: ${NOTIFY_OMD_SITE:-monitoring}
-------------------------------------------"
      
      TICKET_ID=$(create_ydea_ticket "$TITLE" "$DESCRIPTION" "$PRIORITY")
      
      if [[ -n "$TICKET_ID" ]]; then
        log "‚úÖ Ticket creato: #$TICKET_ID per $TICKET_KEY"
        save_ticket_cache "$TICKET_KEY" "$TICKET_ID" "$STATE"
      fi
    fi
  fi
}

# Esegui main
main

exit 0
